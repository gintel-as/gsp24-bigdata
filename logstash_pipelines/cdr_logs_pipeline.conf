input {
    file {
        mode => "read"
        path => "/usr/share/logstash/ingest_data/*-mbn-at*" 
        file_completed_action => "log" 
        file_completed_log_path => "/usr/share/logstash/ingest_data/logstash_completed.log"
    }
}



filter {
  csv {
    separator => "|"
    columns => [
      "callType", "sessionID", "correlationID", "sequenceNumber", "aNumber", 
      "dialledNumber", "cNumber", "servedUser", "servedUserLogin", 
      "redirectNumber", "redirectNumberClir", "originallyCalledNumber", 
      "originallyCalledNumberClir", "genericNumber", "genericNumberDisplayed", 
      "hasClir", "callStartTime", "overheadTime", "pagingTime", "ringingTime", 
      "conversationStartTime", "connectTime", "chargeClass", "chargeParty", 
      "agentOrgName", "agentLogin", "agentNumber", "mscAddress", "vlrNumber", 
      "vpnScenario", "oname", "serviceKey", "pani", "serviceId", 
      "serviceProvider", "generatedPani", "prefix", "postfix", "serviceType", 
      "originatingTerminalNumber", "counterPartyOname", "twoStepLeg2AnswerTime", 
      "counterPartyId", "twoStepLeg2Number", "servedUserPrimary"
    ]
    skip_empty_columns => true
    skip_header => true
  }

  mutate {
    gsub => [
      "callStartTime", " ", "T"
    ]
  }

  date {
    match => ["callStartTime", "yyyy-MM-dd'T'HH:mm:ss"]
    target => "callStartTime"
  }

  if [conversationStartTime] != "\\N" {
    mutate {
      gsub => [
        "conversationStartTime", " ", "T"
      ]
    }

    date {
      match => ["conversationStartTime", "yyyy-MM-dd'T'HH:mm:ss"]
      target => "conversationStartTime"
    }
  }

  mutate {
    convert => {
      "callType" => "integer"
      "sessionID" => "integer"
      "ringingTime" => "integer"
      "overheadTime" => "integer"
      "pagingTime" => "integer"
      "connectTime" => "integer"
    }
  }

  if [conversationStartTime] != "\\N" and [callStartTime] {
    ruby {
      code => "event.set('pickUpTime', (event.get('conversationStartTime').to_f - event.get('callStartTime').to_f))"
    }
  }
}

output {
  elasticsearch {
    index => "cdr_logs-%{+YYYY.MM.dd}"
    hosts=> "${ELASTIC_HOSTS}"
    user=> "${ELASTIC_USER}"
    password=> "${ELASTIC_PASSWORD}"
    cacert=> "certs/ca/ca.crt"
  }
}